name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
      - dev
  workflow_dispatch:
    inputs:
      env:
        type: choice
        description: Select Environment
        required: true
        options:
          - main

permissions:
  actions: read
  contents: write
  security-events: write

jobs:
  security:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    steps:
      - uses: actions/checkout@master
      - name: Static code analysis
        uses: snyk/actions/python@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: code test
          args: --sarif-file-output=snyk.sarif --severity-threshold=high

      - name: Snyk test for supported manifest files
        uses: snyk/actions/python@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          command: test
          args: --sarif-file-output=snyk_2.sarif --severity-threshold=critical --severity-threshold=high

      - name: Count total number of vulnerabilities
        run: |
          RESULTS_LENGTH=$(jq '.runs[0].results | length' snyk.sarif)
          RESULTS_LENGTH_2=$(jq '.runs[0].results | length' snyk_2.sarif)
          TOTAL_RESULTS_LENGTH=$((RESULTS_LENGTH + RESULTS_LENGTH_2))
          echo "TOTAL_RESULTS_LENGTH=$TOTAL_RESULTS_LENGTH" >> $GITHUB_ENV
          echo $TOTAL_RESULTS_LENGTH

      - name: Pass_or_Fail_the_job
        run: |
          if [ "$TOTAL_RESULTS_LENGTH" != 0 ]; then
            echo "Job Failed"
            exit 1
          else
            echo "Pass"
          fi

      - name: Send notification on Teams using Webhooks
        uses: jdcargile/ms-teams-notification@v1.3
        if: always()
        with:
          github-token: ${{ secrets.PAT_TOKEN }}
          ms-teams-webhook-uri: ${{ vars.TEAMS_WEBHOOK_URL }}
          notification-summary: |
            The Snyk scan for repository ${{ github.repository }} has completed with status: ${{ job.status }}
            Number of high vulnerabilities found: ${{ env.TOTAL_RESULTS_LENGTH }}

  docker_build_push_dev:
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' || github.event_name == 'pull_request') && github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install DOCTl Command
        run: |
          sudo snap install doctl
          sudo snap connect doctl:dot-docker

      - name: Login to Digital Ocean Registry
        run: |
          doctl registry login --access-token ${{ secrets.DO_ACCOUNT_TOKEN }}

      - name: Build and Push Docker Image
        run: |
          docker build -t bella-frontend-dev:${{ github.sha }} --build-arg NEXT_PUBLIC_SUPABASE_URL=${{ vars.NEXT_PUBLIC_SUPABASE_URL }} --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }} --build-arg NEXT_PUBLIC_API_URL=${{ vars.NEXT_PUBLIC_API_URL }} --build-arg RESEND_API_KEY=${{ secrets.RESEND_API_KEY }} --build-arg RESEND_AUDIENCE_LIST_ID=${{ secrets.RESEND_AUDIENCE_LIST_ID }} . 
          docker tag bella-frontend-dev:${{ github.sha }} ${{ vars.DO_REGISTRY_URL_DEV }}:${{ github.sha }}
          docker push ${{ vars.DO_REGISTRY_URL_DEV }}:${{ github.sha }}

  deploy_to_kubernetes_dev:
    needs: docker_build_push_dev
    runs-on: ubuntu-latest
    steps:
      - name: Install DOCTL command
        run: |
          sudo snap install doctl
          sudo snap connect doctl:kube-config

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure Digital Ocean Credentials
        run: |
          doctl auth init --access-token ${{ secrets.DO_ACCOUNT_TOKEN }}
          doctl kubernetes cluster kubeconfig save 37a5f702-e1a8-4732-9490-f5e047b5a724

      - name: Deploy Helm on DOKS
        run: |
          helm upgrade --install bella-frontend helm/ \
            --set image.tag=${{ github.sha }} \
            --set nextPublicSupabaseAnonKey=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }} \
            --set imageGenApiKey=${{ secrets.IMAGE_GEN_API_KEY }} \
            --set resendApiKey=${{ secrets.RESEND_API_KEY }} \
            --set resendAudienceListId=${{ secrets.RESEND_AUDIENCE_LIST_ID }} \
            --set lumaaiApiKey=${{ secrets.LUMAAI_API_KEY }} \
            --set falKey=${{ secrets.FAL_KEY }} \
            --set nextPublicVideoApiUrl=${{ secrets.NEXT_PUBLIC_VIDEO_API_URL }} \
            --namespace ${{ vars.NAMESPACE_DEV }} \
            -f helm/environments/dev/values.yaml

  # run_migrations_prod:
  #   runs-on: ubuntu-latest
  #   if: github.ref == 'refs/heads/main'

  #   env:
  #     SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
  #     SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_PRODUCTION_DB_PASSWORD }}
  #     SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PRODUCTION_PROJECT_ID }}

  #   steps:
  #     - uses: actions/checkout@v3

  #     - uses: supabase/setup-cli@v1
  #       with:
  #         version: latest

  #     - run: supabase link --project-ref $SUPABASE_PROJECT_ID
  #     - run: supabase db push
  
  # docker_build_push_prod:
  #   runs-on: ubuntu-latest
  #   if: (github.event_name == 'push' || github.event_name == 'pull_request') && github.ref == 'refs/heads/main'
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v3

  #     - name: Build and Push Docker Image
  #       run: |
  #         sudo snap install doctl
  #         sudo snap connect doctl:dot-docker

  #     - name: Login to Digital Ocean Registry
  #       run: |
  #         doctl registry login --access-token ${{ secrets.DO_ACCOUNT_TOKEN }}

  #     - name: Build and Push Docker Image
  #       run: |
  #         docker build -t bella-frontend-prod:${{ github.sha }} --build-arg NEXT_PUBLIC_SUPABASE_URL=${{ vars.NEXT_PUBLIC_SUPABASE_URL_PROD }} --build-arg SUPABASE_SERVICE_KEY=${{ secrets.SUPABASE_SERVICE_KEY_PROD }} --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY_PROD }} --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY_PROD }} --build-arg NEXT_PUBLIC_IS_LIVE=${{ vars.NEXT_PUBLIC_IS_LIVE }} --build-arg RESEND_AUDIENCE_ID=${{ secrets.RESEND_AUDIENCE_ID }} --build-arg RESEND_API_KEY=${{ secrets.RESEND_API_KEY  }} --build-arg NEXT_PUBLIC_DATADOG_APPLICATION_ID=${{ vars.NEXT_PUBLIC_DATADOG_APPLICATION_ID_PROD }} --build-arg NEXT_PUBLIC_DATADOG_CLIENT_TOKEN=${{ vars.NEXT_PUBLIC_DATADOG_CLIENT_TOKEN_PROD }} --build-arg OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }} . 
  #         docker tag bella-frontend-prod:${{ github.sha }} ${{ vars.DO_REGISTRY_URL_PROD }}:${{ github.sha }}
  #         docker push ${{ vars.DO_REGISTRY_URL_PROD }}:${{ github.sha }}

  # deploy_to_kubernetes_prod:
  #   needs: docker_build_push_prod
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Install DOCTL command
  #       run: |
  #         sudo snap install doctl
  #         sudo snap connect doctl:kube-config

  #     - name: Checkout code
  #       uses: actions/checkout@v3

  #     - name: Configure Digital Ocean Credentials
  #       run: |
  #         doctl auth init --access-token ${{ secrets.DO_ACCOUNT_TOKEN }}
  #         doctl kubernetes cluster kubeconfig save 159d34dc-9948-4fac-a42b-786ff9271beb

  #     - name: Deploy Helm on DOKS
  #       run: |
  #         helm upgrade --install bella-frontend helm/ \
  #           --set image.tag=${{ github.sha }} \
  #           --set replicateApiToken=${{ secrets.REPLICATE_API_TOKEN }} \
  #           --set envConfig.IMAGE_GENERATION_COST=${{ secrets.IMAGE_GENERATION_COST }} \
  #           --namespace ${{ vars.NAMESPACE_PROD }} \
  #           -f helm/environments/prod/values.yaml
          
          

  
          
  

